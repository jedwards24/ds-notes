# Notes on dplyr


OUT OF DATE. NEEDS REWRITING (or possibly just deleting).

This is a fast comprehensive package for data analysis with data frames. Part of the **tidyverse** package.

There are lots of good articles on this package but some may be out of date since the package has evolved a lot since it was first released. The best introduction will be [Hadley's Data Science book](http://r4ds.had.co.nz/) (R4DS), although it is a bit spread out in the book (section 5 introduces dplyr verbs). Another tutorial I started with is [this video](http://www.dataschool.io/dplyr-tutorial-for-faster-data-manipulation-in-r/) which has an [accompanying R markdown document](http://rpubs.com/justmarkham/dplyr-tutorial). There are links to other guides including vignettes on the [official dplyr CRAN site](http://cran.r-project.org/web/packages/dplyr/index.html) (which give a lot of detail at various levels). The talk is based on version 0.2 and there is an [updated talk](https://www.youtube.com/watch?v=2mh1PqfsXVI) on versions 0.3 and 0.4 (with [markdown document](http://rpubs.com/justmarkham/dplyr-tutorial-part-2)). Also [dplyr and pipes: the basics](http://seananderson.ca/2014/09/13/dplyr-intro.html).

There is also a good cheat sheet from RStudio. The whole package is based on tidy data and **tidyr** methods are included on the sheet. 

dplyr is based on using **tibbles** - alternative to data frames. Main differences are printing and subsetting.

* Print just shows 10 rows and columns that fit on screen. Use arguments `n=` and `width=` to change. Can change defaults using `options()`.
* Other displaying options are `glimpse()` and `View()`. `glimpse()` is the dplyr version of `str()` and shows all variables with data transposed
* Row names are not printed. they should not contain data in tidy data.
* Standard dplyr methods always return a tibble. To subset to a vector use `[[` or `$`. To use with a pipe use `.$x` or `.[["x"]]`. Alternatively use `unlist(use.names = FALSE)` (or just `unlist()` to keep names).
* Create using `tibble()` or `tribble()` (transposed tibble), or using `as_tibble()` to coerce an existing df. I think `tbl_df()` and `data_frame()` are the functions in the dplyr package while the others are newer from the tibble package.
* It’s possible for a tibble to have column names that are not valid R variable names, aka non-syntactic names e.g. they might not start with a letter, or they might contain unusual characters like a space. To refer to these variables, you need to surround them with backticks, \`.

In dplyr there are five basic verbs: `filter`, `select`, `arrange`, `mutate`, `summarise`. The first argument for these is the data.

* `filter` subsets observations. There are also a number of other functions to do this is specific ways (see cheatsheet), in particular `slice()` which selects rows by position.
* `select` subsets variables. select columns by giving names as arguments or use helper functions as an argument.
* `arrange` orders rows by a column. Default is low to high. Reverse order using `desc(colname)` instead.
* `mutate` transforms variables to create new ones. `transmute` creates the new variable but drops other columns.
* `summarise` summarises a column with a single value. Usually used following `group_by()` to create summaries for subgroups of a column. Use `ungroup()` to remove grouping.

`count()` and `tally()` can be used to count unique values. The following are equivalent:
```{r eval=F}
mtcars %>% group_by(cyl) %>% summarise(n=n())
mtcars %>% group_by(cyl) %>% tally
count(mtcars, cyl)
```
By using the weight argument to `count()` it can also be used to sum a column:
```{r eval=F}
mtcars %>% group_by(cyl) %>% summarise(tot = sum(mpg))
count(mtcars, cyl, wt=mpg)
```
 To count NAs use `summarise(data, nas=sum(is.na(colname)))`. Could use `count(data, colname, wt=is.na(colname2))` to count NAs per group of another variable. For all variables `summarise_all(funs(sum(is.na(.)))) %>% unlist`.

There are also functions to join, bind or perform set operations on several tibbles. For join functions there is a [guide here](http://stat545.com/bit001_dplyr-cheatsheet.html) but the [relational data](http://r4ds.had.co.nz/relational-data.html) in the R4DS book is very good.

# `mutate()` and `Summarise()`

Grouping and summarise creates a new tibble with new variables which you name in `summarise`. Therefore summarise and mutate are related and have similar structure. The difference is that `summarise` uses **summary or aggregation functions** which take a vector of values and return a single value while `mutate` uses **window functions** which take a vector of values and return a vector of the same length. Therefore `mutate` won't work directly with a user defined function that has scalar inputs. A way around this is to use `rowwise %>% before the mutate call. See [this discussion](https://stackoverflow.com/questions/21818181/applying-a-function-to-every-row-of-a-table-using-dplyr). It is probably better to write a vectorised version of the function I wish to use.

There is a _all, _at, and _if versions of each function (and transmute). These replace the depreciated _each functions that will be found in many guides. They apply operations to multiple variables and the variants are different ways of selecting these variables. Each has an argument `.funs` by which you give the function call that operates on each variable. You can supply a multiple functions to apply by using `funs()` or a character vector (`funs()` can also be used to define transformations inline). See the help file for good examples. Variable selection differs by:

* _all affects every variable.
* _at affects variables selected with a character vector or `vars()`.
* _if affects variables selected with a predicate function e.g `is.numeric` (good for changing variable types).

The predicate or variable arguments come before `.funs`. There are help files for `funs()` and `vars()`. To use `select_helpers` such as `contains()` use `_at` with the helper enclosed in `vars()`.

## Selecting columns as inputs to `mutate()`

This is where I want to use mutate where the new variable is a function of many columns such that I don't want to type them all out explicitly. Note that this is different from selecting columns _to_ mutate. I found several Stack Overflow threads wanting to do this for a sum for which `mutate(sum = rowSums(.[1:4]))` or `mutate(sum=Reduce("+",.[1:4]))` could be used (possibly with `na.rm=T` argument to `rowSSums()`). The indices in square brackets could be replaced by a character vector of variable names also. I'm not as sure about the more general case asked [here](https://stackoverflow.com/questions/28095526/summarise-over-all-columns). `Reduce()` can be used more generally and might be enough (I think it only works with pairwise operations). `?Reduce` gives some other possibly useful functions too. Remember `rowwise` is needed for non-vectorised functions. The link gives an answer using `do()` and `unlist()` which might help understanding.

# Other notes

* There are versions of each verb followed by an underscore which have standard evaluation semantics (see section below). These are now depreciated as their functionality is included in the basic versions (but see below).
* `select()` can be used to rename variables but there is also`rename(..., new=old)` to do this. 
* To reorder columns use `select()` then the new order (numbers or names).
* Slice/filter behaved weirdly on the OCT project, not picking all columns correctly when working with date/time data. Subsetting was ok. Retry with updated packages.
* [Replacing NAs in a dataframe](https://stackoverflow.com/questions/8161836/how-do-i-replace-na-values-with-zeros-in-an-r-dataframe). Lots of different ways of doing this but `mutate_all(d, funs(ifelse(is.na(.), "missing", .)))` illustrates a dplyr method.
* [Useful catalog of argument variations for select](https://www.r-bloggers.com/the-complete-catalog-of-argument-variations-of-select-in-dplyr/)
+ [pivot_](https://speakerdeck.com/yutannihilation/a-graphical-introduction-to-tidyrs-pivot-star). Nice slides on how to use `pivot_longer()` and `pivot_wider()`.

# Standard and Non-standard Evaluation

Standard evaluation (SE) and Non-standard evaluation (NSE).
[introductory article using dplyr](https://www.r-bloggers.com/non-standard-evaluation-and-standard-evaluation-in-dplyr/),
[Hadley advanced R chapter on NSE](http://adv-r.had.co.nz/Computing-on-the-language.html),
[Hadley on NSE in dplyr](http://dplyr.tidyverse.org/articles/programming.html)

## Passing variable names to dplyr functions

I have a function with character variable argument e.g. `var_name`. I then pass this to a dplyr function (e.g. arrange) within the function. This doesn't work since the usual functions only use standard evaluation and therefore looks for a column called "var_name" rather than the name stored in `var_name`. A solution is to use the SE versionof the function `arrange_`. To arrange in descending order you must construct a string  `paste0("desc(", "var_name)")`. A vector of columns can also be passed using `.dots` argument. See [here](https://stackoverflow.com/questions/38052325/arrange-multiple-columns-with-descending-order). I suspect there will be other ways to do this since `arrange_` is supposed to be depreciated (use quosures?).

## Issues with NSE

When using `dplyr` inside my own function I had a problem with lots of `Note: no visible binding for global variable xxxx` messages. This doesn't stop code from running an isn't an error, but is annoying. It has been a bigger problem for people producing packages and there are several threads (e.g. [compiler issues](https://stackoverflow.com/questions/24258770/using-compiler-package-and-suppress-no-visible-binding-for-global-variable)
[main thread - ggplot](https://stackoverflow.com/questions/9439256/how-can-i-handle-r-cmd-check-no-visible-binding-for-global-variable-notes-when)) about it (the problems occur with `ggplot` and `compiler` too). I didn't find any of the solutions ideal but did manage to fix it.

My example is the function:

```
summarise_over <- function(results_df, mean_var){
  summary <- results_df %>% 
    group_by_("exper_no", "pol_no", mean_var) %>%
    summarise(mean_r1 = mean(expect_r1), mean_r2 = mean(expect_r2)) %>%
    mutate(mean_r_all = (mean_r1 + mean_r2) / 2)
  return(summary)
}
```
When run this will give messages that no visible binding is found for ... `expect_r1`, `expect_r2`, `mean_r1` and `mean_r2`. These are variable names is `results_df` so are handled correctly because `dplyr` understands them to be e.g. `df$expect_r1` but R thinks they are don't exist.

Some solutions are to create the variables somewhere, either as global variables e.g. `globalVariables(c("expect_r1", "expect_r2"))` "somewhere in the top-level of your package" or in the function as `expect_r1 <- expect_r2 <- NULL`. For `dplyr`/`ggplot` use of SE functions e.g. `mutate_()` to avoid NSE can fix this but it was tricky to implement in my example. due too the operations I was doing on the variables (`mean_r1 + mean_r2`). Elsewhere Jenny Bryant suggests this for piping (but it didn't fix my problem):
```
## quiets concerns of R CMD check re: the .'s that appear in pipelines
if(getRversion() >= "2.15.1")  utils::globalVariables(c("."))
```
The version check is to ensure it works with older versions.

## Other Issues

[Fixing a multiple warning “unknown column”](https://stackoverflow.com/questions/39041115/fixing-a-multiple-warning-unknown-column/42536153). There is an interaction with RStudio's disgnostics that can produce unnecessary warnings. It's quite annoying so worth avoiding. It may be fixed in future versions of RStudio but a workaround is to either turn off diagnostics in `Preferences/Code/Diagnostics` or add `# !diagnostics off` at the top of files.
